\subsection{Overview}
The project is split into two applications, one written in Python and the other written in Java. The reason for this is we determined that much of the functionality of displaying graphs of data, and handling data in general was much better suited to python than to any other programming language we were confident with. Furthermore we determined that java would be much better suited to create the video game in than python given the more rigorous syntax and typing, and better object oriented support. From there we divided the responsibility of the system between the two applications as described below. 

\textbf{Python}
\begin{itemize}
    \item \textbf{Dashboard views}, as the handling of data and generation of graphs is very well supported in Python.
    \item \textbf{Design suggestions}, as the Python application already has to read the telemetry data, and thus components processing it are more simple to implement in the Python application.
    \item \textbf{Simulation views}, as the simulation generates telemetry identical to that of users, and as the Python application can already handle user made telemetry and display it, the functionality for displaying simulation generated telemetry is almost entirety already in the Python application, requiring minimal additional work to implement. 
    \item \textbf{Decision Log View}, although not to be implemented in sprint one, it is planned that the Python application will be the access point to the design log, as this allows the cross-examination of logged decisions and the telemetry data that is used to justify those decisions.
\end{itemize}

\textbf{Java}
\begin{itemize}
    \item \textbf{Role Assignment}, as Java is a more rigorous language than python, and the application requires more complex role based access control due to the implementation of design parameters, it was determined that the Java application should manage role assignment. Specifically, as it was required for the system to operate, but not specified which role should have this permission in the specification, we chose to give only developers the ability to assign roles as this best fit with their role of maintaining the application.
    \item \textbf{Design Parameters}, as the Java application is the only application influenced by the value of the design parameters, we determined those should be set in the Java application, as well as read and written to a configuration file by the Java application. In the next sprint we plan to add a section to the design parameter setting menu that requires designers and developers to justify their changes, which will be stored in the decision log.
    \item \textbf{Telemetry Setting}, as the java application collects telemetry, it was decided the user setting to disable this would be located in the settings menu of the java application.
    \item \textbf{Video Game}, due to java's extensive support of object oriented programming, and due to the fact that video games are generally very well suited to this paradigm it was decided the video game that produces the telemetry events would be coded on the Java application. 
\end{itemize}
\subsection{Python Application}
\subsubsection{Overview}
The Python application acts as a visualiser for telemetry data gained from the Java game. The application is composed of a frontend and a backend, with the frontend responsible for displaying view dashboards, suggestions, and displaying authentication. Whilst the backend is responsible for authentication logic for both the python telemetry application and Java game and parsing json gained from the Java game, sending graphical representations to the frontend.
\subsubsection{Authentication}
\paragraph{Overview}
Both the Python and Java applications utilise Google OAuth to authenticate users, assigning them with the default role of Player if they do not already exist in the logins file. Authentication then returns user and role information to the application that calls it.
\paragraph{auth}
\paragraph{auth\_wrapper}
\subsubsection{core}
\paragraph{Overview}
\paragraph{events}
\paragraph{export}
\paragraph{logic}
\paragraph{parsing}
\subsubsection{gui}
\paragraph{Overview}
\paragraph{gui}
\paragraph{plotting}
\paragraph{telemetry\_app}
\subsection{Java Application}
\subsubsection{Overview}
The Java application was first split into front end and back end. From there the responsibilities of the backend were further divided into several singletons the front end would access. Each singleton was given responsibility for a particular area, and that area was further divided between different objects it composited. The front end then uses these singletons to perform the calculations required to run the game, and displays this information to the user. 
\begin{comment}
\subsubsection{Design Principles}
%not sure about this section if it's relevant or should be removed. 
\paragraph{Testability}
The Java application was designed with testing as a priority, specifically to allow the extensive use of mock objects. The first way this is achieved is through the use of a modified singleton pattern, where the concrete singleton is nested within a different class that provides access. This allows the concrete singleton to implement an interface, and thus allows the rest of the system to work around that interface rather than the singleton itself. This allows the switching out of the concrete singleton instance for a mock object for testing. Furthermore many of the objects within the java application are built around interfaces rather than implementations, to allow those objects to be swapped out for mock objects for testing.

Another way in which the application is designed with testing in mind is by allowing the directories of all file writes to be modified, to allow a temporary directory to be setup for testing where mock events and configuration files are written and read to, and the resetting the destination of the systems that write files after the test is complete.
\paragraph{Extensability}
Its already been mentioned about the principle of programming to an interface for the purposes of testing, but this has also been done to allow extensibility as the interface can be extended and implemented by a different class to allow the functionality of the program to be extended, while maintaining compatibility with the current system following the open-close principle. 

Another area in which the system supports extensibility is through it's upgrade system, using the decorator pattern it allows a player to be extended with any number of upgrades, as well as the creation of further upgrades. This upgrade system works in tandem with the ability system to allow upgrades to change how effective abilities are based on their damage type. Although the upgrade system currently does not do this, it does also support the ability to modify variables of the player such as health, lives, max health, magic etc. which could be implemented at a future date.
\paragraph{Reusability}
The system is also designed with reusability in mind, ensuring every component is reusable, and duplication is minimal. One example of this is in the ability system, which is the same for all entities both player and enemy. This allows us to get significant millage out of just a small number of abilities. 

Another way the system makes good use of the resources it has is through it's encounter system. As an encounter can comprise of multiple enemies, allowing us to make use of enemies that the player would otherwise be very strong against in later encounters. Furthermore encounters at most stages are randomised, providing variety to each run, along with the randomisation of what abilities are purchasable in the shop. 
\end{comment}

\subsubsection{Abilities}
\paragraph{Overview}
Abilities internally refer to what are called attack abilities in the documentation, this is because passive abilities are fully handled by the upgrade system and thus it is clear that an ability internally refers to an attack ability. Abilities all have common characteristics and work in a similar way based on these characteristics and thus are represented as an enum.
\paragraph{AbilityEnum}
Ability enum enumerates all of the game's abilities for both enemies and the player. Each ability is represented by several key characteristics, which are stored in each enum instance: the base damage amount, the damage type, the magic cost, the name for the ability in the telemetry system, and a description of the ability. 

The execute method is in charge of actually using the ability in the backend, requiring the source (who used the ability) and target (who is being attacked). It reduces the source's magic by the abilities cost if they're a player (or throws an exception if they do not have enough magic to use it) and otherwise ignoring the magic system for enemies. It then interfaces with the upgrade system to determine the final damage amount which the target's health is then reduced by.
\subsubsection{Upgrades}
\paragraph{Overview}
The upgrade system uses the decorator pattern to add additional functionality to the player dynamically. Upgrades are stored in the game run and some are then picked out of the shop and displayed to the user. Upgrades internally refer to what are called passive and attack abilities in the documentation. 
\paragraph{UpgradeEnum}
All upgrades have several common characteristics (price, decorator class, and telemetry name), these are stored within the upgrade enum, which is used by all systems to represent upgrades. The other classes in the upgrade system serve only as decorators and are never directly interacted without outside of upgrade enum. 

The upgrade enum also provides the functionality for applying upgrades to the player, which is done through reflection of the stored upgrade class. Each upgrade takes a PlayerInterface as a parameter to it's constructor, and holds a reference to the player, which it forwards most function calls to. It then returns the newly constructed upgrade as a PlayerInterface.
\paragraph{UpgradeBase}
Upgrade base is the parent of all upgrades. It stores the reference to the player, and forwards all PlayerInterface calls to the player. It is an abstract class.
\paragraph{ResistanceUpgrades}
Resistance upgrades are a specific type of passive upgrade that provides resistance to a damage type, halving the damage the player takes of that type. 

Like all upgrades they override the getUpgrades() method to append a reference to their UpgradeEnum instance to the result of calling it for the internal player. This is used to keep track of which upgrades the player has. 


Additionally, the override the loseHealth() method, checking if the damage type is that which they provide resistance to, and halving it if it is. It then forwards this loseHealth() call to the internal player.
\paragraph{AbilityUnlockUpgrades}
Ability unlock upgrades are concrete implementations of UpgradeBase that are used to unlock abilities (called attack abilities in documentation).

Similarly to ResistanceUpgrades, the override the getUpgrades method to add a reference to their enum instance to it. 

Furthermore they override the getAbilities() method, first obtaining the abilities of the internal player and then appending a reference to the AbilityEnum instance for their relevant ability.
\subsubsection{Encounters}
\paragraph{Overview}
Similarly to upgrades, there is a finite number of pre-made encounters, consisting of one or more enemies. 
\paragraph{EncounterEnum}
This represents all the pre-made encounters in the game, holding a list of all enemy enums in the encounter and the name of the encounter for telemetry purposes. It is used when referring to the type of encounter rather than a specific concrete encounter, and thus mostly appears within telemetry. 

It contains the ability to produce a concrete encounter from the enum value. This method is currently unused but serves as a utility for future work and extension of the system. 
\paragraph{EncounterInterface}
This defines the interface for a concrete encounter, and is used by all classes that deal with actual encounters with concrete enemies. 

It has methods allowing access to the enemies within it, as well as the ability to reset their health (in the case the player dies and restarts the encounter), and mark it as complete (to prevent it reappearing later in the run). It also contains the ability to get the EncounterEnum value for the encounter, which is used when producing telemetry relating to it.
\paragraph{Encounter}
This is the concrete implementation of EncounterInterface. It holds a reference to each enemy instance within the encounter and other information required to service the interface.

The concrete encounter is only ever referenced when creating an encounter, which is done when a new GameRun is instantiated. 
\subsubsection{Enemies}
\paragraph{Overview}
Both the player and enemies within this game are considered entities. All abilities work on entities, and wherever they can be used instead of enemies or players they are (e.g. in encounters). 
\paragraph{EntityAIInterface}
This defines the interface for the AI used for both enemies as well as running the simulation of the game. It defines methods for determining and using an ability, as well as determining what to buy in the shop. 
\paragraph{EntityAISingleton}
This defines a singleton with a single instance of a concrete implementation of EntityAIInterface. In the prototype this implementation uses randomness to determine which abilities to use and what upgrades to buy in the shop. 

The singleton class provides static global access to the instance of random EntityAI, which is used by the UI to determine which ability each enemy uses on the player, and what the simulated player does. 
\paragraph{EntityEnum}
EntityEnum acts like EncounterEnum for entities, grouping common characteristics based on entirety type rather than instance. It thus stores a reference to the class used to instantiate the enemy, and a telemetry safe name for them. It is used mainly by the telemetry system and EncounterEnum. 

It allows the creation of enemies from the enum, which is done through reflection. This is currently unused by the system, but could become useful in future extensions of the system.
\paragraph{EntityInterface}
TODO
\paragraph{EnemyBase}
EnemyBase is an abstract class that implements the core functionality all enemy instances have in common. Each concrete enemy then extends this class.

It takes in both health and max health values, calculated by the enemy passing them in based of it's base health value and the design parameters (the design parameter for health is not implemented so returns a default value). 

It then provides methods for working with health (lose, reset, get) as well as a default implementation for calculating how much damage an ability it uses should deal.
\paragraph{ConcreteEnemies}
Concrete enemies extend EnemyBase, providing enemy specific methods and fields. 

In their constructor they calculate how much health they should have, sending that to the constructor of their superclass (EnemyBase). 

They then override getAbilities() to add to it the abilities the enemy has, and implement getType() to return the type o enemy as EnemyEnum. 

Some also override loseHealth() if they have damage vulnerabilities (double damage from source) or damage resistances (half damage from source). 
\subsubsection{Player}
\paragraph{Overview}
The player system handles information relating to the player of the game, this is the user's character within the game, and is not related to the player role. Each run is given a new player which then gains upgrades from the shop as the game run progresses.
\paragraph{PlayerInterface}
This defines the interface for the player, and extends EntityInterface with functionality exclusive to players.

It provides methods for dealing with coins (which are obtained at the end of encounters, and spend in the shop), lives (which are lost each time the player dies), and magic (which increases each round in an encounter, is spent to use magically abilities), and upgrades.
\paragraph{Player}
This is the concrete implementation of the player interface. It contains values for all data related to the player, including health, coins, and magic.
\subsubsection{Telemetry}
\paragraph{Overview}
The telemetry system is in charge of validating and writing telemetry to the correct telemetry store (dependant on if it's a simulation or an actual user). It uses java's delegation model.
\paragraph{TelemetryListenerInterface}
This specifies the interface for the telemetry listener instance. It contains methods to handle all telemetry events, and is what's used by sources to send telemetry events to the instance (Obtained via TelemetryListenerSingleton)
\paragraph{TelemetryListenerSingleton}
TODO
\paragraph{TelemetryEvent}
\paragraph{EncounterEvent}
\paragraph{EncounterCompleteEvent}
\paragraph{EncounterFailEvent}
\paragraph{ConcreteTelemetryEvent}

\subsubsection{Time}
\subsubsection{Settings}
\subsubsection{Game Mangement}
\subsubsection{User Interface}
\subsubsection{Authentication}