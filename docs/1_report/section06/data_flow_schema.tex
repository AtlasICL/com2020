\subsection{Overview}
The system uses several data stores to keep track of both telemetry data, as well as user data such as settings and roles. Each subsection within this section represents one data store. In it will be described what data it stores, what components use that data, and what the data is used for.
\subsection{Telemetry Events}

\subsubsection{Data Stored}

\paragraph{Overview}
This data store contains all user generated telemetry events. Each event stores user data as specified in the telemetry schema. All the data is stored as one large JSON list, with many JSON objects, where each object represents a single telemetry event. 

\paragraph{Common Fields}
The type of object is specified by the event field as a string. The sessionID is a 32 bit int, randomly generated for each run, and thus the chance of duplicate session ids is negligible for the scale of the application. Should this become an issue later on they can be migrated to a UUID, which can handle significantly more sessions before collisions become likely. The userID is the sub provided by google OAuth and thus pseudonymous with the user. Lastly each event is timestamped with when it was created in 
the format year/month/day/hour/minute/second. 

\paragraph{Other Fields}
The difficulty field stores the difficulty of a run as a string. The encounter\_name field stores the name for the encounter, based on the predefined encounters. The stage\_number field stores which stage the event was generated on. The player\_HP\_remaining field contains how much health the player finished an encounter with. the lives\_left field contains how many lives the player has when they fail an encounter. The coins\_gained field contains how many coins the player gained from completing an encounter. The upgrade\_bought field contains the telemetry name of the upgrade bought from the shop, and coins\_spent contains how much it cost to buy. The setting field contains the name of the setting changed, and the setting\_value contains the new value of the setting as a string. The enemy\_type field contains the telemetry name of the enemy that was killed.

\subsubsection{Data Used}

\paragraph{Java Application}
The Java application never reads telemetry events. It appends to the file with new events provided the user has telemetry enabled, and then saves its changes as to not lock the file.

\newpage
\paragraph{Python Application}
The Python application only ever reads from telemetry events. It does so every 3 seconds to live update its telemetry views. It validates incoming data, then uses it to determine how many players survive each stage (funnel view), how often players die on each stage (Difficulty Spikes), how much health players finish each stage with, for each difficulty (Health Comparison), and how many coins player finish each stage with (Coins Comparison). It also checks to see if the number of failures on a stage is above average and if so suggests tweaks to the design parameters to make the stage easier.

\subsection{Simulated Telemetry Events}

\subsubsection{Data Stored}

\paragraph{Overview}
This data store is identical to that of telemetry events, except it stores events generated by simulated runs. As a result a description of the data format is unneeded.

\subsubsection{Data Used}

\paragraph{Java Application}
The Java application never reads simulated events. It appends to the file with new events provided the user has telemetry enabled when they run the simulated run. The events are those generated by the simulated player. 

\paragraph{Python Application}
The Python application only ever reads from simulated events. It does so every 3 seconds to live update its telemetry view while set to view simulated telemetry. It uses this data in the exact same way as it does user data, to generate the different dashboard views and design suggestions. 

\subsection{Logins}

\subsubsection{Data Stored}

\paragraph{Overview}
This data store contains the login information of each user. It does so in a plaintext JSON file, as for this sprint the focus is on producing a functioning prototype, but this could be secured next sprint. 

\paragraph{Common Fields}
Each entry in the file contains a key of the userID and a value of the user's role. User roles are updated by modifying the role value in the prototype, however after sprint 2 we aim to add a role assignment mechanism within the Java app. 

\newpage
\subsubsection{Data Used}

\paragraph{Java Application}
The Java application never directly reads this data. It instead makes a authentication request to the Python application, which reads the user data after authenticating them, and sends this to the Java app through its output stream. The Java app uses their userID for telemetry events, and uses their role for role-based access control as defined in the sprint plan.

\paragraph{Python Application}
The Python application writes to this file when a new user is created, by default assigning them the role of player due to the least privilege security principle. It reads from the file when authenticating a user that has been authenticated before, keeping note of their role and userID. It uses their role to ensure correct role-based access control as defined in the sprint plan, and displays their userID to them in the home tab.  

\subsection{Settings File}

\subsubsection{Data Stored}

\paragraph{Overview}
This data store keeps track of all design parameter values along with user settings. It does so using two top levels fields, one for user data, and the other for design parameter data. 

\paragraph{User Data}
The user data stores a JSON object of users, where each key is the user's userID and the value is their user settings. The user's settings consist of if they have telemetry enabled, an unused role setting, and the furthest level they've reached on each difficulty. This is also currently unused, but will be used to display player progress in sprint 2.

\paragraph{Desing Parameters}
The design parameters are stored in another JSON object. This object has keys for each design parameter name and each value is another JSON object, having a key for each difficulty and storing the value of the design parameter for that difficulty. 

\subsubsection{Data Used}

\paragraph{Java Application}
The user data information is read by the Java application after authenticating a user to obtain their telemetry setting. If they have telemetry disabled the app will not store telemetry events in either event stores. It also reads from the file on user login to obtain the values for all design parameters across each difficulty, storing this data. This data is then used to determine the design parameter values during gameplay. 

The application writes to the file when a user enables or disables telemetry, storing their choice. It also writes to the file when a design parameter is changed, to store the update should the game be restarted. 

\paragraph{Python Application}
The Python application does not use this data store. 